#!/bin/bash

# function
function checkTools(){
	if [ `which $1` ];then
		echo0 3 "$1: `which $1`"
	else
		echo0 0 "$1 not found, please install it or add it into your PATH!"
		exit 1
	fi
}

# help information
help_info(){
	TS=$0
	echo0 4 $0
	echo0 4 "\t-i <file>\tin.bed2 for picluster define"
	echo0 4 "\t-C <file>\tchrom.size file"
	echo0 4 "\t-p <path/text>\tprefix for output."
	echo0 5 "parameters for cluster defining:"
	echo0 5 "\t-w <int>\twindow size used. default: 30000"
	echo0 5 "\t-s <int>\tshift size used. default: 1000"
	echo0 5 "\t-d <int>\tdistance to merge two potential piRNA produce window. default: 10000"
	echo0 5 "\t-R <int|float:0-1>\tcutoff for RPM or Portion. -R accept two types of data: float from 0-1 and interger bigger than 1 default: 0.6"
	echo0 5 "\t\t\tset to interger will use reads per million mapped reads as cutoff"
	echo0 5 "\t\t\tset to float will calculate a cutoff dynamically depends on how many reads the cutoff can illustrate"
	echo0 5 "\t-S <int>\tcutoff for sequence number. default: 200"
	echo0 5 "\t-U <float:0-1>\tcutoff for 1U or 10A reads percentage in a cluster. default: 0.5"
	echo0 5 "\t-u <float:0-1>\tcutoff for unique mapped percentage in a cluster. default: 0.25"
	echo0 5 "\t-T <float:0-1>\tread percentage need to cover when trim piclusters. default: 0.85"
	echo0 5 "\t-c <int>\tthreads. default: 1"
	echo0 3 "other option:"
	echo0 3 "\t-b <file>\twatson strand bigWig file, use with -B. default: make from bed2 file"
	echo0 3 "\t-B <file>\tcrick strand bigWig file, use with -b. default: make from bed2 file"
	echo0 3 "\t-e <file>\twatson strand bigWig file for species, use with -E. default: make from bed2 file"
	echo0 3 "\t-E <file>\tcrick strand bigWig file for species, use with -e. default: make from bed2 file"
	echo0 3 "\t-P \tpreserve tmp files."
	echo0 1 ""
	echo0 1 "Before running `basename $0`, please first mapping smallRNAseq data to genome with rRNA, miRNA, sncRNA removed using srna_map."
}

if [ $# -lt 1 ];then
	help_info && exit 1
fi

# parameters
WINDOW_SIZE=30000
SHIFT_SIZE=1000
MERGE_DISTANCE=10000
CPU=1
CUTOFF_RPM=100
CUTOFF_SEQ=200
CUTOFF_BIN_SEQ=2
TOP_SIZE=32
BOTTOM_SIZE=24
ONEU_PERCENT=0.5
UNIQ_PERCENT=0.25
CUTOFF_TRIM=0.85


while getopts "hi:C:w:s:d:R:S:U:p:c:b:B:e:E:PT:u:" OPTION; do
	case $OPTION in
		h)	help_info && exit 0;;
		i)	BED2_IN=`readlink -f ${OPTARG}`;;
		C)	CHROM_SIZE=`readlink -f ${OPTARG}`;;
		p)	PREFIX=`readlink -f ${OPTARG}`;;
		w)	WINDOW_SIZE=${OPTARG};;
		s)	SHIFT_SIZE=${OPTARG};;
		d)	MERGE_DISTANCE=${OPTARG};;
		R)	CUTOFF_RPM=${OPTARG};;
		S)	CUTOFF_SEQ=${OPTARG};;
		U)	ONEU_PERCENT=${OPTARG};;
		u)	UNIQ_PERCENT=${OPTARG};;
		T)	CUTOFF_TRIM=${OPTARG};;
		b)	BIGWIG_WATSON=`readlink -f ${OPTARG}`;;
		B)	BIGWIG_CRICK=`readlink -f ${OPTARG}`;;
		e)	BIGWIG_SPECIES_WATSON=`readlink -f ${OPTARG}`;;
		E)	BIGWIG_SPECIES_CRICK=`readlink -f ${OPTARG}`;;
		P)	CLOSE_REMOVE=1;;
		c)	CPU=${OPTARG};;
		*)	help_info && exit 1
	esac
done
echo ${BED2_IN}

# check parameters
echo0 4 "------ preparation ------"
echo0 1 "check parameters......"
[ -z ${BED2_IN} ] && echo0 0 "please provide bed2 file via -i" && exit 1
[ -z ${CHROM_SIZE} ] && echo0 0 "please chrom.size file via -C" && exit 1
[ ! -f ${BED2_IN} ] && echo0 0 "bed2 file error, no file in ${BED2_IN}" && exit 1
[ ! -f ${CHROM_SIZE} ] && echo0 0 "chrom.size file error, no file in ${CHROM_SIZE}" && exit 1
[ ! -d `dirname ${PREFIX}` ] && (mkdir -p `dirname ${PREFIX}` || (echo0 0 "`dirname ${PREFIX}` not found and cann't be make" & exit 1))
! [ "${SHIFT_SIZE}" -gt 0 ] 2>/dev/null && echo0 0 "shift_size need to be integer bigger than 0" && exit 1
! [ "${WINDOW_SIZE}" -gt "${SHIFT_SIZE}" ] 2>/dev/null && echo0 0 "window_size need to be integer and bigger than shift size" && exit 1
! [ "${CPU}" -gt 0 ] 2>/dev/null && echo0 0 "threads need to be integer bigger than 0" && exit 1
! [ "${CUTOFF_SEQ}" -gt 0 ] 2>/dev/null && echo0 0 "cutoff for sequence need to be integer bigger than 0" && exit 1
! [ "${CUTOFF_RPM}" -gt 0 ] 2>/dev/null && echo0 4 "Warning: -R is not integer, please check if it is between 0-1" && SWITCH_RPM=1
[ ! -z ${BIGWIG_WATSON} ] && [ ! -f ${BIGWIG_WATSON} ] && echo0 0 "-b set but ${BIGWIG_WATSON} not found" && exit 1
[ ! -z ${BIGWIG_CRICK} ] && [ ! -f ${BIGWIG_CRICK} ] && echo0 0 "-B set but ${BIGWIG_CRICK} not found" && exit 1
[ ! -z ${BIGWIG_WATSON} ] && [ -z ${BIGWIG_CRICK} ] && echo0 0 "-b set but -B not set" && exit 1
[ ! -z ${BIGWIG_CRICK} ] && [ -z ${BIGWIG_WATSON} ] && echo0 0 "-B set but -b not set" && exit 1
[ ! -z ${BIGWIG_SPECIES_WATSON} ] && [ ! -f ${BIGWIG_SPECIES_WATSON} ] && echo0 0 "-e set but ${BIGWIG_WATSON} not found" && exit 1
[ ! -z ${BIGWIG_SPECIES_CRICK} ] && [ ! -f ${BIGWIG_SPECIES_CRICK} ] && echo0 0 "-E set but ${BIGWIG_CRICK} not found" && exit 1
[ ! -z ${BIGWIG_SPECIES_WATSON} ] && [ -z ${BIGWIG_SPECIES_CRICK} ] && echo0 0 "-e set but -E not set" && exit 1
[ ! -z ${BIGWIG_SPECIES_CRICK} ] && [ -z ${BIGWIG_SPECIES_WATSON} ] && echo0 0 "-E set but -e not set" && exit 1
echo0 1 "OK......"

# check dependencies
echo0 1 "check dependencies......"
checkTools makeWindows 
checkTools ParaFly 
checkTools bedtools 
checkTools define_picluster.trim_end.py 
checkTools define_picluster.judge_strand.py 
echo0 1 "OK......"

###########
# process #
###########

echo0 4 "------ processing ------"
# judge rpm cutoff for picluster defining
if [ ! -z ${SWITCH_RPM} ];then
	echo0 2 "judge rpm cutoff for picluster defining......"
	CUTOFF_PORTION=`awk -v cr=${CUTOFF_RPM} 'BEGIN{print cr*100"%"}'`
	# sum2 means unique mapped reads, sum1 means piRNA reads based on read size
	CUTOFF_RPM=`awk -v ts=${TOP_SIZE} -v bs=${BOTTOM_SIZE} -v cr=${CUTOFF_RPM} -v ws=${WINDOW_SIZE} \
		'BEGIN{FS=OFS="\t"} \
		{if(($3-$2)>=bs && ($3-$2)<=ts&& (substr($7,1,1)=="T" || substr($7,10,1)=="A")){w=$1":"int($2/ws);a[w]+=$4/$5;sum1+=$4/$5};\
		if($5==1){sum2+=$4}} \
		END{slen=asort(a,sa);\
		for(i=slen;i>0;i--){sum3+=sa[i];if(sum3>sum1*cr){print sa[i]*1000000/sum2;break}}}' ${BED2_IN}`
	echo0 3 "rpm cutoff is set to ${CUTOFF_RPM} to cover ${CUTOFF_PORTION} piRNA reads"
fi

# make slide windows and bigWig files
echo0 2 "make slide windows using ${WINDOW_SIZE} windown size with shift size ${SHIFT_SIZE}......"
makeWindows ${CHROM_SIZE} ${WINDOW_SIZE} ${SHIFT_SIZE} > ${PREFIX}.W${WINDOW_SIZE}.S${SHIFT_SIZE}.bed
awk '$6=="+"' ${PREFIX}.W${WINDOW_SIZE}.S${SHIFT_SIZE}.bed > ${PREFIX}.tmp.window.watson.bed # split watson and crick windowns 
awk '$6=="-"' ${PREFIX}.W${WINDOW_SIZE}.S${SHIFT_SIZE}.bed > ${PREFIX}.tmp.window.crick.bed 
if [ -z ${BIGWIG_WATSON} ];then
	echo0 2 "make bigWig signal files of bed2 file for piRNA reads, normalized by unique mapped reads......"
	FACTOR=`awk '{if($5==1){sum+=$4}} END{print sum/1000000}' ${BED2_IN}`
	awk -v ts=${TOP_SIZE} -v bs=${BOTTOM_SIZE} '($3-$2)>=bs && ($3-$2)<=ts && (substr($7,1,1)=="T" || substr($7,10,1)=="A")' ${BED2_IN} > ${PREFIX}.tmp.reads.bed2
	bed2_to_bw.py ${PREFIX}.tmp.reads.bed2 ${CHROM_SIZE} ${PREFIX}.tmp.reads ${FACTOR} ${CPU}
	BIGWIG_WATSON=${PREFIX}.tmp.reads.watson.all.bw 
	BIGWIG_CRICK=${PREFIX}.tmp.reads.crick.all.bw 
fi
if [ -z ${BIGWIG_SPECIES_WATSON} ];then
	echo0 2 "make bigWig signal files of bed2 file for piRNA species......"
	awk -v ts=${TOP_SIZE} -v bs=${BOTTOM_SIZE} 'BEGIN{FS=OFS="\t"} {$4=1;if(($3-$2)>=bs && ($3-$2)<=ts && (substr($7,1,1)=="T" || substr($7,10,1)=="A")){print $0}}' ${BED2_IN} > ${PREFIX}.tmp.species.bed2
	bed2_to_bw.py ${PREFIX}.tmp.species.bed2 ${CHROM_SIZE} ${PREFIX}.tmp.species 1 ${CPU}
	BIGWIG_SPECIES_WATSON=${PREFIX}.tmp.species.watson.all.bw 
	BIGWIG_SPECIES_CRICK=${PREFIX}.tmp.species.crick.all.bw 
fi
rm ${PREFIX}.W${WINDOW_SIZE}.S${SHIFT_SIZE}.bed

# calculate rpm for each window and filter windows without enough rpm
echo0 2 "calculate rpm and species for each window......"
PARA_FILE=${PREFIX}.tmp.para # use paraFly for parallel
echo -e "bigWigAverageOverBed ${BIGWIG_WATSON} ${PREFIX}.tmp.window.watson.bed ${PREFIX}.tmp.reads.watson.bwave && cut -f 1,4 ${PREFIX}.tmp.reads.watson.bwave > ${PREFIX}.tmp.reads.watson.rpm" > ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_CRICK} ${PREFIX}.tmp.window.crick.bed ${PREFIX}.tmp.reads.crick.bwave && cut -f 4 ${PREFIX}.tmp.reads.crick.bwave > ${PREFIX}.tmp.reads.crick.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_WATSON} ${PREFIX}.tmp.window.watson.bed ${PREFIX}.tmp.species.watson.bwave && cut -f 4 ${PREFIX}.tmp.species.watson.bwave > ${PREFIX}.tmp.species.watson.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_CRICK} ${PREFIX}.tmp.window.crick.bed ${PREFIX}.tmp.species.crick.bwave && cut -f 4 ${PREFIX}.tmp.species.crick.bwave > ${PREFIX}.tmp.species.crick.rpm" >> ${PARA_FILE}
ParaFly -c ${PARA_FILE} -CPU ${CPU} > ${PARA_FILE}.log 2>&1 && rm ${PARA_FILE}*
echo0 2 "filter windows with rpm and piRNA species less than ${CUTOFF_RPM} and ${CUTOFF_SEQ} respectively......"
paste ${PREFIX}.tmp.reads.watson.rpm ${PREFIX}.tmp.reads.crick.rpm \
	${PREFIX}.tmp.species.watson.rpm ${PREFIX}.tmp.species.crick.rpm | \
	awk '{if($2=="nan"){$2=0;$3=0;$4=0;$5=0};print $0}' > ${PREFIX}.tmp.window.rpm
	awk -v cr=${CUTOFF_RPM} -v cs=${CUTOFF_SEQ} 'BEGIN{FS=OFS="\t"} \
	{if(($2+$3)>=cr && ($4+$5)>cs){split($1,t,":");print t[1],t[2],t[3],$2+$3,$4+$5,"."}}' \
	${PREFIX}.tmp.window.rpm > ${PREFIX}.tmp.filtered.bed # strand is also take into account by strand reads and species bias

# merge overlapped windows as candidate piRNA clusters
echo0 2 "merge overlapped windows as candidate piRNA clusters......"
awk -v ds=${MERGE_DISTANCE} 'BEGIN{FS=OFS="\t"} \
	{if(NR==1){chr=$1;st=$2;ed=$3}\
	else{if($1==chr && $2<=(ed+ds)){ed=$3}else{k++;print chr,st,ed,"piC."k,0,".";chr=$1;st=$2;ed=$3}}} \
	END{k++;print chr,st,ed,"piC."k,0,"."}' ${PREFIX}.tmp.filtered.bed > ${PREFIX}.tmp.filtered.merged.bed 

# trim candidate piRNA clusters
echo0 2 "chop candidate piRNA clusters into 100bp bins......"
awk 'BEGIN{FS=OFS="\t"} {k=0;for(i=0;i<($3-$2)/100;i++){k++;print $1,$2+i*100,$2+(i+1)*100,$4"-"k,$5,$6}}' ${PREFIX}.tmp.filtered.merged.bed > ${PREFIX}.tmp.filtered.merged.chopped.bed 
echo0 2 "calculate rpm and species for each chopped bin......"
PARA_FILE=${PREFIX}.tmp.para # use paraFly for parallel
echo -e "bigWigAverageOverBed ${BIGWIG_WATSON} ${PREFIX}.tmp.filtered.merged.chopped.bed ${PREFIX}.tmp.reads.watson.bwave && cut -f 1,4 ${PREFIX}.tmp.reads.watson.bwave > ${PREFIX}.tmp.reads.watson.rpm" > ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_CRICK} ${PREFIX}.tmp.filtered.merged.chopped.bed ${PREFIX}.tmp.reads.crick.bwave && cut -f 4 ${PREFIX}.tmp.reads.crick.bwave > ${PREFIX}.tmp.reads.crick.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_WATSON} ${PREFIX}.tmp.filtered.merged.chopped.bed ${PREFIX}.tmp.species.watson.bwave && cut -f 4 ${PREFIX}.tmp.species.watson.bwave > ${PREFIX}.tmp.species.watson.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_CRICK} ${PREFIX}.tmp.filtered.merged.chopped.bed ${PREFIX}.tmp.species.crick.bwave && cut -f 4 ${PREFIX}.tmp.species.crick.bwave > ${PREFIX}.tmp.species.crick.rpm" >> ${PARA_FILE}
ParaFly -c ${PARA_FILE} -CPU ${CPU} > ${PARA_FILE}.log 2>&1 && rm ${PARA_FILE}*
echo0 2 "determine 5' and 3' ends for each piRNA cluster......"
paste ${PREFIX}.tmp.reads.watson.rpm ${PREFIX}.tmp.reads.crick.rpm \
	${PREFIX}.tmp.species.watson.rpm ${PREFIX}.tmp.species.crick.rpm | \
	awk '{if($2=="nan"){$2=0;$3=0;$4=0;$5=0};print $0}' > ${PREFIX}.tmp.window.merged.chopped.rpm
MAX_CUTOFF_RPM_BIN=`awk -v cr=${CUTOFF_RPM} 'BEGIN{print cr/5}'`
define_picluster.trim_end.py ${PREFIX}.tmp.window.merged.chopped.rpm ${PREFIX}.tmp.end1 ${CUTOFF_TRIM} 2 ${MAX_CUTOFF_RPM_BIN} 1000
awk 'BEGIN{FS=OFS="\t"} \
	{if(NR==FNR){fe[$1]=$2;te[$1]=$3}else{$3=$2+te[$4];$2=$2+fe[$4];print $0}}' \
		${PREFIX}.tmp.end1 ${PREFIX}.tmp.filtered.merged.bed | awk '($3-$2)>0' > ${PREFIX}.tmp.piC.bed

# determine the strand information of piRNA cluster
echo0 2 "chop piclusters into 100bp bins and calculate rpm and species......"
awk 'BEGIN{FS=OFS="\t"} {k=0;for(i=0;i<($3-$2)/100;i++){k++;print $1,$2+i*100,$2+(i+1)*100,$4"-"k,$5,$6}}' ${PREFIX}.tmp.piC.bed > ${PREFIX}.tmp.piC.chopped.bed 
PARA_FILE=${PREFIX}.tmp.para # use paraFly for parallel
echo -e "bigWigAverageOverBed ${BIGWIG_WATSON} ${PREFIX}.tmp.piC.chopped.bed ${PREFIX}.tmp.reads.watson.bwave && cut -f 1,4 ${PREFIX}.tmp.reads.watson.bwave > ${PREFIX}.tmp.reads.watson.rpm" > ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_CRICK} ${PREFIX}.tmp.piC.chopped.bed ${PREFIX}.tmp.reads.crick.bwave && cut -f 4 ${PREFIX}.tmp.reads.crick.bwave > ${PREFIX}.tmp.reads.crick.rpm" >> ${PARA_FILE}
ParaFly -c ${PARA_FILE} -CPU ${CPU} > ${PARA_FILE}.log 2>&1 && rm ${PARA_FILE}*
echo0 2 "judge strand for each piRNA cluster, also judge breakpoints for divergence piRNA cluster......"
paste ${PREFIX}.tmp.reads.watson.rpm ${PREFIX}.tmp.reads.crick.rpm > ${PREFIX}.tmp.piC.chopped.rpm
define_picluster.judge_strand.py ${PREFIX}.tmp.piC.chopped.rpm ${PREFIX}.tmp.strand
awk 'BEGIN{FS=OFS="\t"} \
	{if(NR==FNR){str[$1]=$2;bp[$1]=$3}\
	else{\
		if(str[$4]=="-+"){\
			k++;print $1,$2,$2+bp[$4],"piC."k,1,"-";\
			k++;print $1,$2+bp[$4],$3,"piC."k,1,"+"}\
		else{k++;print $1,$2,$3,"piC."k,0,str[$4]}}}' \
	${PREFIX}.tmp.strand ${PREFIX}.tmp.piC.bed > ${PREFIX}.tmp.piC.strand.bed

# trim both ends again for stranded piRNA cluster
echo0 2 "trim both ends again for stranded piRNA clusters using loose criteria......"
awk 'BEGIN{FS=OFS="\t"} {k=0;for(i=0;i<($3-$2)/100;i++){k++;print $1,$2+i*100,$2+(i+1)*100,$4"-"k,$5,$6}}' ${PREFIX}.tmp.piC.strand.bed > ${PREFIX}.tmp.piC.strand.chopped.bed
PARA_FILE=${PREFIX}.tmp.para # use paraFly for parallel
echo -e "bigWigAverageOverBed ${BIGWIG_WATSON} ${PREFIX}.tmp.piC.strand.chopped.bed ${PREFIX}.tmp.reads.watson.bwave && cut -f 1,4 ${PREFIX}.tmp.reads.watson.bwave > ${PREFIX}.tmp.reads.watson.rpm" > ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_CRICK} ${PREFIX}.tmp.piC.strand.chopped.bed ${PREFIX}.tmp.reads.crick.bwave && cut -f 4 ${PREFIX}.tmp.reads.crick.bwave > ${PREFIX}.tmp.reads.crick.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_WATSON} ${PREFIX}.tmp.piC.strand.chopped.bed ${PREFIX}.tmp.species.watson.bwave && cut -f 4 ${PREFIX}.tmp.species.watson.bwave > ${PREFIX}.tmp.species.watson.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_CRICK} ${PREFIX}.tmp.piC.strand.chopped.bed ${PREFIX}.tmp.species.crick.bwave && cut -f 4 ${PREFIX}.tmp.species.crick.bwave > ${PREFIX}.tmp.species.crick.rpm" >> ${PARA_FILE}
ParaFly -c ${PARA_FILE} -CPU ${CPU} > ${PARA_FILE}.log 2>&1 && rm ${PARA_FILE}*
paste ${PREFIX}.tmp.reads.watson.rpm ${PREFIX}.tmp.reads.crick.rpm \
	${PREFIX}.tmp.species.watson.rpm ${PREFIX}.tmp.species.crick.rpm > ${PREFIX}.tmp.piC.strand.chopped.rpm
define_picluster.trim_end.py ${PREFIX}.tmp.piC.strand.chopped.rpm ${PREFIX}.tmp.end2 ${CUTOFF_TRIM} 2 ${MAX_CUTOFF_RPM_BIN} 5000
awk 'BEGIN{FS=OFS="\t"} \
	{if(NR==FNR){fe[$1]=$2;te[$1]=$3}else{$3=$2+te[$4];$2=$2+fe[$4];print $0}}' \
	${PREFIX}.tmp.end2 ${PREFIX}.tmp.piC.strand.bed > ${PREFIX}.tmp.piC.strand.trim.bed

# filter piRNA cluster again with loose criteria and write out final piRNA clusters
echo0 2 "calculate rpm and species for stranded and trimed piRNA clusters......"
PARA_FILE=${PREFIX}.tmp.para # use paraFly for parallel
echo -e "bigWigAverageOverBed ${BIGWIG_WATSON} ${PREFIX}.tmp.piC.strand.trim.bed ${PREFIX}.tmp.reads.watson.bwave && cut -f 1,4 ${PREFIX}.tmp.reads.watson.bwave > ${PREFIX}.tmp.reads.watson.rpm" > ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_CRICK} ${PREFIX}.tmp.piC.strand.trim.bed ${PREFIX}.tmp.reads.crick.bwave && cut -f 4 ${PREFIX}.tmp.reads.crick.bwave > ${PREFIX}.tmp.reads.crick.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_WATSON} ${PREFIX}.tmp.piC.strand.trim.bed ${PREFIX}.tmp.species.watson.bwave && cut -f 4 ${PREFIX}.tmp.species.watson.bwave > ${PREFIX}.tmp.species.watson.rpm" >> ${PARA_FILE}
echo -e "bigWigAverageOverBed ${BIGWIG_SPECIES_CRICK} ${PREFIX}.tmp.piC.strand.trim.bed ${PREFIX}.tmp.species.crick.bwave && cut -f 4 ${PREFIX}.tmp.species.crick.bwave > ${PREFIX}.tmp.species.crick.rpm" >> ${PARA_FILE}
ParaFly -c ${PARA_FILE} -CPU ${CPU} > ${PARA_FILE}.log 2>&1 && rm ${PARA_FILE}*
paste ${PREFIX}.tmp.reads.watson.rpm ${PREFIX}.tmp.reads.crick.rpm \
	${PREFIX}.tmp.species.watson.rpm ${PREFIX}.tmp.species.crick.rpm > ${PREFIX}.tmp.piC.strand.trim.rpm
echo0 2 "filter piRNA clusters with loose rpm and species criteria......"
PREFIX_NAME=`basename ${PREFIX}`
awk -v cr=${CUTOFF_RPM} -v cs=${CUTOFF_SEQ} \
	'BEGIN{FS=OFS="\t"} \
	{if(NR==FNR){a[$1]=$2";"$3";"$4";"$5}\
	else{\
		split(a[$4],s,";");\
		if($5==1){tcr=cr/2;tcs=cs/4}else{tcr=cr;tcs=cs/2};\
		if((s[1]+s[2])>=tcr && (s[3]+s[4])>=tcs){\
			print $1,$2,$3,$4,a[$4],$6}\
		}}' ${PREFIX}.tmp.piC.strand.trim.rpm ${PREFIX}.tmp.piC.strand.trim.bed | sort -k1,1 -k2,2n > ${PREFIX}.tmp.piC2.bed
echo0 2 "filter piRNA clusters without enough 1U or 10A percentage and enough unique mapped reads......"
bedtools intersect -sorted -a ${PREFIX}.tmp.piC2.bed -b ${BED2_IN} -wo -nonamecheck > ${PREFIX}.tmp.intersect
awk -v prefix=${PREFIX_NAME} -v cr=${CUTOFF_RPM} -v cs=${CUTOFF_SEQ} -v up=${UNIQ_PERCENT} 'BEGIN{FS=OFS="\t"} \
	{if(NR==FNR){a[$4]+=$10/$11;as[$4]+=1/$11;if(substr($13,1,1)=="T" || substr($13,10,1=="A")){t[$4]+=$10/$11;ts[$4]+=1/$11};if($11==1){u[$4]+=$10;us[$4]+=1}}\
	else{if(a[$4]>0 && u[$4]>cr*up && us[$4]>cs*up){k++;name="pi-"prefix"-"k;print $1,$2,$3,name,$5,$6,t[$4]/a[$4],ts[$4]/as[$4]}}}' \
	${PREFIX}.tmp.intersect ${PREFIX}.tmp.piC2.bed > ${PREFIX}.tmp.piC2.ATp.bed 
awk -v pt=${ONEU_PERCENT} -v prefix=${PREFIX_NAME} 'BEGIN{FS=OFS="\t"} {if($7>pt || $8>pt){k++;$4="pi-"prefix"-"k;print $1,$2,$3,$4,$5,$6}}' ${PREFIX}.tmp.piC2.ATp.bed > ${PREFIX}.piC.bed 
mv ${PREFIX}.tmp.piC2.ATp.bed ${PREFIX}.piC.ATp.bed 

# remove tmp files
[ -z ${CLOSE_REMOVE} ] && echo0 2 "remove tmp files" && rm ${PREFIX}.tmp*
TIME_USED=${SECONDS}

echo0 4 "------finished🍺🍺🍺------"
echo0 3 "Time used:\t$((${TIME_USED} / 3600))h $((${TIME_USED} / 60))m"
